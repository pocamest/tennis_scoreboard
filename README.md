# Tennis Scoreboard (Теннисное табло)

Реализация веб-приложения "Теннисное табло" с фокусом на архитектурные паттерны.

**Цель проекта:** Практика в проектировании слоистой архитектуры (MVCS) и ручной реализации веб-серверной части (WSGI) без использования крупных веб-фреймворков.

---

## Запуск

1.  **Настройка `.env` файла:**
    -   `cp .env.example .env`
    -   Заполнить переменные для подключения к БД (DB_URL, DB_ECHO) и, при необходимости, для сервера (APP_HOST, APP_PORT) в .env.

2.  **Установка зависимостей:**
    -   Для разработки (включая dev-зависимости): `uv sync`
    -   Для продакшена: `uv sync --no-dev`
    *Эта команда автоматически создаст `.venv` и установит зависимости.*

3.  **Миграции БД:**
    -   `uv run alembic upgrade head`

4.  **Старт сервера:**
    -   `uv run python main.py`
    -   Сервер будет доступен по адресу, настроенному в .env файле (по умолчанию http://127.0.0.1:8080).

---

## Тестирование

-   Юнит-тестирование доменной логики счета
-   **Запуск тестов:** `uv run pytest`

---

## Архитектурные Решения

Зафиксированные принципы для поддержания консистентности кода.

#### 1. Структура Пакетов (`app/`)
Проект разделен на следующие логические слои. Каждый слой может быть реализован как пакет (`имя_слоя/`) или как одиночный модуль (`имя_слоя.py`) в зависимости от текущей сложности.

-   **Слой Контроллеров:** Обработка HTTP-запросов.
-   **Слой Сервисов:** Оркестрация бизнес-операций.
-   **Слой Репозиториев:** Инкапсуляция логики доступа к данным.
-   **Слой Домена:** "Сердце" приложения. Содержит чистые Python-объекты (`dataclass`-ы) с "богатой" доменной логикой (Rich Domain Model). **Ничего не знает о БД.**
-   **Слой Моделей:** Слой Персистентности. Содержит "анемичные" ORM-модели SQLAlchemy, описывающие схему БД.
-   **Слой Схем:** Валидация "грязных" данных извне (Pydantic).

#### 2. Проектирование Моделей
Принято решение разделять доменную логику и логику персистентности, чтобы избежать проблем со сложностью и хранением в ORM-объектов данных не предназначенных для БД.

-   **Когда разделять?** Разделение применяется, когда проявляется хотя бы один из сигналов:
    1.  У концепции есть **разные жизненные циклы** (например, "живой" объект в памяти и "архивная" запись в БД).
    2.  Бизнес-логика объекта **сложна** и требует изоляции для надежного тестирования.
    3.  "Чистый" доменный объект должен зависеть от концепции, представленной "грязной" ORM-моделью.

-   **Ключевые принципы проектирования** задокументированы в `docstring`-ах соответствующих пакетов.
    -   Для `app/domain` это принципы Rich Domain Model.
    -   Для `app/models` основная идея — `relationship` используется только для фундаментальных структурных связей.

#### 3. Конвенция Именования Разделенных Моделей
-   **Если доменная концепция имеет разные роли в разных контекстах, ее модели получают разные, говорящие имена.**
    -   **Пример:** `domain.OngoingMatch` (матч в "живом" состоянии) и `models.Match` (матч как запись в архиве).

-   **Если доменная концепция сохраняет свою суть в разных контекстах, ее модели получают одинаковое, каноническое имя.**
    -   **Пример:** И в `app/domain`, и в `app/models` класс называется `Player`.
    -   **Разрешение конфликтов:** Конфликт имен решается **локально** в сервисах через псевдонимы при импорте (`as DomainPlayer`, `as OrmPlayer`).

#### 4. Именование Методов в Слоях

-   **Repository (`app/repositories/`):** Имена технические, описывают *КАК* получаются данные.
    -   `get_*(...)`: Строгий поиск одного объекта по уникальному ключу. Возвращает объект или бросает исключение `NotFoundError`.
    -   `find_one_*(...)`: Безопасный поиск одного объекта. Возвращает `Объект | None`.
    -   `find_many_*(...)`: Поиск множества. Возвращает `list[Объект]`.
    -   Суффикс `_with_<relation>` используется для обозначения жадной загрузки.

-   **Service (`app/services/`):** Имена описывают бизнес-операцию (*ЧТО* мы делаем), например, `get_all_matches()`.

-   **Controller (`app/controllers/`):** Имена описывают действие пользователя или страницу (*ЗАЧЕМ*), например, `show_index_page()`.