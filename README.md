# Tennis Scoreboard (Теннисное табло)

Реализация веб-приложения "Теннисное табло" с фокусом на архитектурные паттерны.

**Цель проекта:** Практика в проектировании архитектуры MVCS и ручной реализации веб-серверной части (WSGI) без использования веб-фреймворков.

---

## Запуск

1.  **Настройка `.env` файла:**
    -   `cp .env.example .env`
    -   Заполнить переменные для подключения к БД (DB_URL, DB_ECHO) и, при необходимости, для сервера (APP_HOST, APP_PORT) в .env.

2.  **Установка зависимостей:**
    -   Для разработки (включая dev-зависимости): `uv sync`
    -   Для продакшена: `uv sync --no-dev`

3.  **Миграции БД:**
    -   `uv run alembic upgrade head`

4.  **Старт сервера:**
    -   `uv run python main.py`
    -   Сервер будет доступен по адресу, настроенному в .env файле (по умолчанию http://127.0.0.1:8080).

---

## Тестирование

-   Юнит-тестирование доменной логики счета
-   **Запуск тестов:** `uv run pytest`

---

## Архитектурные Решения

Зафиксированные принципы для поддержания консистентности кода.

#### 1. Структура Пакетов (`app/`)
Проект разделен на следующие логические слои. Каждый слой может быть реализован как пакет (`имя_слоя/`) или как одиночный модуль (`имя_слоя.py`) в зависимости от текущей сложности.

-   **Слой Контроллеров:** Обработка HTTP-запросов.
-   **Слой Сервисов:** Оркестрация бизнес-операций.
-   **Слой Репозиториев:** Инкапсуляция логики доступа к данным.
-   **Слой Домена:** Содержит чистые Python-объекты (`dataclass`-ы) с "богатой" доменной логикой (Rich Domain Model). **Ничего не знает о БД.**
-   **Слой Моделей:** Слой Персистентности. Содержит "анемичные" ORM-модели SQLAlchemy, описывающие схему БД.
-   **Слой Схем:** Валидация "грязных" данных извне (Pydantic).

#### 2. Проектирование Моделей

-   **Ключевые принципы проектирования** задокументированы в `docstring`-ах соответствующих пакетов.
    -   Для `app/domain` это принципы Rich Domain Model.
    -   Для `app/models` основная идея — `relationship` используется только для фундаментальных структурных связей.

#### 3. Конвенция Именования Разделенных Моделей
-   **Если доменная концепция имеет разные роли в разных контекстах, ее модели получают разные, говорящие имена.**
    -   **Пример:** `domain.OngoingMatch` (матч в "живом" состоянии) и `models.Match` (матч как запись в архиве).

-   **Если доменная концепция сохраняет свою суть в разных контекстах, ее модели получают одинаковое, каноническое имя.**
    -   **Пример:** И в `app/domain`, и в `app/models` класс называется `Player`.

#### 4. Именование Методов в Слоях

-   **Repository (`app/repositories/`):** Имена технические, описывают *КАК* получаются данные.
    -   `get_*(...)`: Строгий поиск одного объекта по уникальному ключу. Возвращает объект или бросает исключение `NotFoundError`.
    -   `find_one_*(...)`: Безопасный поиск одного объекта. Возвращает `Объект | None`.
    -   `find_many_*(...)`: Поиск множества. Возвращает `list[Объект]`.

-   **Service (`app/services/`):** Имена описывают бизнес-операцию (*ЧТО* мы делаем), например, `get_all_matches()`.

-   **Controller (`app/controllers/`):** Имена описывают назначение страницы (*ЗАЧЕМ*), например, `show_index_page()`.